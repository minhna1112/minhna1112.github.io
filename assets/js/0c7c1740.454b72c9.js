"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[262],{5711:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>a,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"ivsr/orbnet-2022","title":"ORB-Net","description":"Accepted into ISR europe 2023","source":"@site/docs/ivsr/orbnet-2022.md","sourceDirName":"ivsr","slug":"/ivsr/orbnet-2022","permalink":"/docs/ivsr/orbnet-2022","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"MonoIS3DLoc","permalink":"/docs/ivsr/monois3dloc-2022"}}');var i=t(4848),o=t(8453);const a={},s="ORB-Net",c={},l=[{value:"Key Contributions",id:"key-contributions",level:2},{value:"Acknowledgments",id:"acknowledgments",level:2}];function d(e){const n={a:"a",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"orb-net",children:"ORB-Net"})}),"\n",(0,i.jsx)(n.h1,{id:"end-to-end-planning-using-feature-based-imitation-learning-for-autonomous-drone-racing",children:"End-to-end Planning Using Feature-based Imitation Learning for Autonomous Drone Racing"}),"\n",(0,i.jsxs)(n.p,{children:["Accepted into ",(0,i.jsx)(n.a,{href:"https://ieeexplore.ieee.org/abstract/document/10363048",children:"ISR europe 2023"})]}),"\n",(0,i.jsx)(n.h2,{id:"key-contributions",children:"Key Contributions"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"ORB-Net as a neural architecture that could regress motions (translational and yawn velocity) from RGB images and ORB feature maps extracted from a feature extractor (ORB)"}),"\n",(0,i.jsx)(n.li,{children:"Technical contributions: Custom Dataloader implemented in PyTorch, used for batching ORB, ORB-mask, RGB images, RGBO to feed into the training pipeline."}),"\n",(0,i.jsx)(n.li,{children:"Imitation Learning pipeline to train the ORB-Net model from an expert PID-controlled agent, via continuous sampling trajectories and mixing policies from both the expert and the agent controller (ORB-Net)."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"acknowledgments",children:"Acknowledgments"}),"\n",(0,i.jsxs)(n.p,{children:["Special thanks to all the co-authors from ",(0,i.jsx)(n.a,{href:"https://github.com/IVSR-SET-HUST/",children:"IVSR Lab"})," and ",(0,i.jsx)(n.a,{href:"https://github.com/open-airlab",children:"Aarhus University's OpenAirlab"}),". All the simulated trajectories data used in training are from OpenAirlab's Unreal Engine-made ",(0,i.jsx)(n.a,{href:"https://github.com/open-airlab/autonomous-drone-racing",children:"Drone Racing Environment"}),"."]})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>s});var r=t(6540);const i={},o=r.createContext(i);function a(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);